# -*- coding: utf-8 -*-
"""Clasificacion_Vino.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vLZsjyr1ZODXu7kFr0J8Nu6IoP5nkcvv
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
from scipy.stats import skew
from scipy.stats import pearsonr
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.linear_model import SGDClassifier
from sklearn.metrics import confusion_matrix, classification_report
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import train_test_split, GridSearchCV, cross_val_score
# %matplotlib inline

warnings.filterwarnings('ignore')
# %matplotlib inline

"""## De que depende la Calidad del Vino Tinto?

- Variables

 - **Fixed acidity** : Cantidad de acido tartico medido en g/dm3
 - **Volatile acidity**: Cantidad de acido acetico medido en g/dm3
 - **Citrid acid**: Cantidad de acido citrico medido en g/dm3
 - **Residual sugar** : Cantidad de azucar despues de la fermentacion medida en g/dm3
 - **Chlorides** : Cantidad de cloruros medido en g/dm3
 - **Free Sulfur Dioxide**: Cantidad de dioxido de azufre medida en g/dm3
 - **Total Sulfur Dioxido**: Cantidad total de azufre en el vino medido en g/dm3
 - **density**: Indica la densidad del vino, medido en g/dm3
 - **ph**: Ph del vino, donde 0 indica ph muy alto y 14 ph basico
 - **slphates** : Cantidad de sulfato de potasio, medido en g/dm3
 - **alcohol** : Indica la cantidad de alcohol
 - **quality** : Indica la calidad del vino en un rango de 0 a 10. El valor 10 indica la mas alta calidad del vino.
"""

df = pd.read_csv('/content/sample_data/winequality-red.csv')
df.head(4)

df.dtypes
# todas las variables son float(decimales) y solo la variable calidad es del tipo entero.

df.shape

df.describe()
# Se observa la cantidad de registro en cada variable es la misma (1599 obs)

df.info()
# otra forma de obtener rapidamente info sobre la df.
# no se observan NA

"""### Análisis descriptivo"""

t_frec = df.groupby('quality')['quality'].count()
t_frec

# Se observa que hay una mayor frecuencia de vinos entre la calidad 5 y 6.
# ademas se evidencia que no existen vinos con calidad 1,2,9 y 10.-

# Examinemos la correlacion

sns.heatmap(df.corr(), annot=True, fmt='.2f', linewidths=2)

# Resultados
# La calidad tiene correlacion con el acohol (0.48), con el sulfato (0.25),
# con el grado de acido citrico (0.23) y fixed acidity (0.12).
# La calidad tiene una correlacion negativa con volaite acidity (-0.39)

# Analisis de la densidad del Alcohol

sns.distplot(df['alcohol'])
plt.show()

# podemos ver que la distribución del alcohol está positivamente sesgada con la calidad del vino.

skew(df['alcohol'])

# EL resultado confirma lo sesgado del acohol con la calidad del vino.
# podriamos hacer el mismo ejercicio con las demas variables.

# Alcohol vs Calidad

p=sns.boxplot(x = 'quality', y = 'alcohol', data=df)
p.set(title = "Calidad del Vino versus la cantidad de acohol")
plt.show()

# Se observa que la calidad del vino en 5 y 6 presentan datos atipicos.
# para corregir este hecho podriamos apartalos y volver a realizar el grafico

# Indicamos que no muestre los outliers

p=sns.boxplot(x = 'quality', y = 'alcohol', data=df, showfliers=False)
p.set(title = "Calidad del Vino versus la cantidad de acohol (sin outliers)")
plt.show()


# Se observa que a medida que la cantidad de alcohol crece, tambien lo hace la calidad
# del vino.

# funcion para encontrar la correlacion entre 2 columnas

def obtener_correlacion(columna1, columna2, df):
    pearson_corr, p_value = pearsonr(df[columna1], df[columna2])
    print("Correlacion entre {} y {} es {}".format(columna1,
columna2, pearson_corr))
#    print("P-value de esta correlacion es {}".format(p_value))

# veamos como funciona
obtener_correlacion('alcohol','pH', df)
# Resultado muy cercano al obtenido por medio del heatmap

# Analisis Acido citrico
fig = plt.figure(figsize = (15,6))
p=sns.boxplot(x = 'quality', y = 'citric acid', data = df)
p.set(title = "Niveles de Acido Citrico versus Calidad del Vino")
plt.show()
# Se observa que a medida que aumenta la cantidad de acido citrico, aumenta la calidad del vino

# Analisis Sulfato
fig = plt.figure(figsize = (15,6))
p=sns.boxplot(x = 'quality', y = 'sulphates', data = df)
p.set(title = "Niveles de Sulfatos versus Calidad del Vino")
plt.show()
# Se observa que a medida que aumenta la cantidad de sulfatos, aumenta la calidad del vino, aunque menor medida que los niveles de acido citrico
# se observa una gran cantidad de outliers

# Analisis Residual sugar
fig = plt.figure(figsize = (15,6))
p=sns.boxplot(x = 'quality', y = 'residual sugar', data = df)
p.set(title = "Niveles Azucar residual versus Calidad del Vino")
plt.show()
# No se observa que los niveles de azucar residual influyan en la calidad del vino (tienen el mismo nivel)
# se observa una gran cantidad de outliers

# Analisis Volaite Acidity
fig = plt.figure(figsize = (15,6))
p=sns.boxplot(x = 'quality', y = 'volatile acidity', data = df)
p.set(title = "Volatile Acidity  residual versus Calidad del Vino")
plt.show()
# Se observa una relación negativa, es decir, a mayores niveles Volaite Acidity menor es la calidad del vino
# se observa una gran cantidad de outliers

# Analisis Free Sulfur Dioxide
fig = plt.figure(figsize = (15,6))
p=sns.boxplot(x = 'quality', y = 'free sulfur dioxide', data = df)
p.set(title = "Volatile Acidity  residual versus Calidad del Vino")
plt.show()
# no se observa claramente una relacion con la calidad del vino
# se observa una gran cantidad de outliers

"""### Predicción de la Calidad del Vino"""

# Desde calidad 7 hacia arriba se califica como Bueno, en caso contrario, Malo
bins = (2, 6.5, 8)
group_names = [0, 1]
df['quality'] = pd.cut(df['quality'], bins = bins, labels = group_names)

# Se crea la variable que determina que 0 es mala y 1 buena calidad

# Conteo de casos
df['quality'].value_counts(normalize=True)

# El 46% corresponde a vinos de buena calidad

# grafico de clases de vino
p = sns.countplot(df['quality'])
p.set(title = "Cantidad de vinos por calidad")
plt.show()

# Separación de la data
X = df.drop('quality', axis = 1)
y = df['quality'] # variable objetivo


# train y Test data
# se utiliza el 20% para el test, y con un numero aleatorio 42
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42)

# Para obtener resultados optimizados
sc = StandardScaler()

X_train = sc.fit_transform(X_train)
X_test = sc.fit_transform(X_test)

"""## **Ahora se puede utilizar algun algoritmo de clasificación**


1 - **Randon Forest**

"""

rfc = RandomForestClassifier(n_estimators=200)
rfc.fit(X_train, y_train)
pred_rfc = rfc.predict(X_test)

# observamos el comportamiendo del modelo
print(classification_report(y_test, pred_rfc))

# matriz de confusión
print(confusion_matrix(y_test,pred_rfc))

"""El Algoritmo **random forest** tiene una eficiencia del **86%**

**2-Support Vector Classifier**
"""

svc = SVC()
svc.fit(X_train, y_train)
pred_svc = svc.predict(X_test)

print(classification_report(y_test, pred_svc))

print(confusion_matrix(y_test, pred_svc))

"""El Algoritmo **Support Vector** tiene una eficiencia del **86%**

#**Aumentar la eficiencia de los algoritmos**

A - Utilizando una grilla para encontrar los mejores parametros en SVM
"""

# Grilla
param = {
    'C': [0.1,0.8,0.9,1,1.1,1.2,1.3,1.4],
    'kernel':['linear', 'rbf'],
    'gamma' :[0.1, 0.8,0.9,1,1.1,1.2,1.3,1.4]
}
grid_svc = GridSearchCV(svc, param_grid=param, scoring='accuracy', cv=10)

grid_svc.fit(X_train, y_train)

# mejores parametros
grid_svc.best_params_

# ahora los utilizamos y observamos el accuracy
svc2 = SVC(C = 1.2, gamma =  0.9, kernel= 'rbf')
svc2.fit(X_train, y_train)
pred_svc2 = svc2.predict(X_test)
print(classification_report(y_test, pred_svc2))

"""Un gran avance, pasamos del **86%** al **90%** utilizando los mejores parametros encontrados.

**B** - Validación Cruzada para **Random Forest**

Procedimiento de “re-sampling” (remuestreo) que permite evaluar un modelo.  Se utiliza para comparar los diferentes modelos y seleccionar el más adecuado para un problema específico. Esta técnica que tiene menos sesgos que los demás métodos.
"""

#Random Forest
rfc_eval = cross_val_score(estimator = rfc, X = X_train, y = y_train, cv = 10)
rfc_eval.mean()

"""Aumentamos del **86%** al **91%** utilizando validacion cruzada."""

# Datos de accuracy
data = {
    'Model': ['Random Forest', 'SVC Ajustado'],
    'Accuracy': [0.9132, 0.90]
}

# Crear DataFrame
comparison_df = pd.DataFrame(data)

# Mostrar la tabla
print(comparison_df)
